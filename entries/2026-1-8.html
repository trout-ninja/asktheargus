<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2026-1-8 -- Take it Slow in the Directory </title>
<link rel="canonical" href="https://www.asktheargus.com/entries/2026-1-8.html" />
  
  <style>
    body { margin:0; padding:24px; font-family:serif; background:#0b1d3a; color:#ff6b6b; line-height:1.6; }
    .frame { padding:26px; border:14px solid transparent; border-radius:10px; max-width:900px; margin:0 auto;
      border-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Cg fill='none' stroke='%23ff2b2b' stroke-width='4' stroke-linecap='round'%3E%3Cpath d='M8 16c8 0 8-8 16-8s8 8 16 8 8-8 16-8'/%3E%3Cpath d='M8 48c8 0 8 8 16 8s8-8 16-8 8 8 16 8'/%3E%3Cpath d='M16 8c0 8-8 8-8 16s8 8 8 16-8 8-8 16'/%3E%3Cpath d='M48 8c0 8 8 8 8 16s-8 8-8 16 8 8 8 16'/%3E%3C/g%3E%3C/svg%3E") 20 round;
    }
    a { color:#d36a1e; text-decoration:none; border-bottom:1px solid rgba(211,106,30,.5); }
    a:hover { color:#ff2b2b; border-bottom-color:#ff2b2b; }
    h1 { color:#ff2b2b; margin:0; font-size:2.6rem; }
    .meta { margin-top:.25rem; opacity:.9; }
    h2 { color:#ff2b2b; margin-top:2rem; }
    ul { margin: .5rem 0 0 1.2rem; }
    .tagbox { margin-top:1rem; padding:14px; border:1px solid rgba(255,107,107,.25); border-radius:8px; }
  </style>
</head>
<body>
  <div class="frame">
    <p><a href="../index.html">&larr; Back to Home</a></p>

    <h1></h1>
    <div class="meta">2026-1-8</div>

    <h2>What I Worked On</h2>
      <!-- Write your entry here -->
<p>I spent all day yesterday further reviewing the bootloader process and got lost in it. I still don’t understand all of it, but I suspect that if I move on in my studies, things will become more clear.</p>

<p>I’ve decided that updating the website every day is too daunting, and it’s probably best left to the weekends. I’ll write my entries as I go along, but uploading everything daily is simply too time-consuming for my studies.</p>

<p>I’m also pasting this here so I can review it later, because Shevek made it easy to memorize:</p>

<pre><code>Firmware (BIOS/UEFI)
  └─ logs to firmware interfaces

Bootloader (GRUB)
  └─ logs to screen / serial
  └─ LOADS kernel + initramfs
  └─ JUMPS to kernel entry point
       ← bootloader logging ENDS here

Kernel (early init)
  └─ logs via early printk
  └─ initializes memory, scheduler, drivers
  └─ mounts initramfs as temporary root

initramfs (/init)
  └─ logs via kernel facilities
  └─ prepares real root filesystem

systemd (PID 1)
  └─ logs to journald</code></pre>

<p>There. Hopefully I can reference this whenever I’m feeling lost.</p>

<p>I download and begin the <i>root_directory_explorer</i> and I’m totally unimpressed. But I proceed anyway for the mental discipline. I answer the questions to make sure my own knowledge is on par—which is always lacking. I paste important notes to remember here. The first question asks me to name 10 top-level directories and their contents. I’ll copy and paste it here for memorization, and I’ll be making flash cards so it’s etched into my mind:</p>

<table border="1" cellpadding="8" cellspacing="0">
  <thead>
    <tr>
      <th>Directory</th>
      <th>Purpose</th>
    </tr>
  </thead>
  <tbody>
    <tr><td><code>/bin</code></td><td>Essential user command binaries required for basic system operation and recovery.</td></tr>
    <tr><td><code>/sbin</code></td><td>Critical system administration binaries used for booting, repair, and maintenance.</td></tr>
    <tr><td><code>/etc</code></td><td>System-wide configuration files and service configuration directories.</td></tr>
    <tr><td><code>/usr</code></td><td>Userland applications, libraries, and shared read-only resources.</td></tr>
    <tr><td><code>/var</code></td><td>Variable data that changes during runtime (logs, caches, spools, databases).</td></tr>
    <tr><td><code>/home</code></td><td>Personal directories for non-root users and their data.</td></tr>
    <tr><td><code>/root</code></td><td>Home directory for the root user, isolated from <code>/home</code>.</td></tr>
    <tr><td><code>/boot</code></td><td>Kernel images, bootloader files, and initramfs needed to start the system.</td></tr>
    <tr><td><code>/dev</code></td><td>Device nodes representing hardware and virtual devices as files.</td></tr>
    <tr><td><code>/proc</code></td><td>Virtual filesystem exposing live kernel and process information.</td></tr>
    <tr><td><code>/sys</code></td><td>Virtual filesystem exposing kernel objects, drivers, and device attributes.</td></tr>
    <tr><td><code>/tmp</code></td><td>Temporary files intended for short-term use; often cleared on reboot.</td></tr>
    <tr><td><code>/run</code></td><td>Volatile runtime state (PID files, sockets) available early in the boot process.</td></tr>
  </tbody>
</table>

<p>I move on to the next mission. It requests that I compare my real directory to the virtual one. I attempt to do so, but the lab comes to a screeching halt when I can’t even look at the virtual directory contents of <code>/proc</code>. I take screenshots and send them to Shevek. He provides a less-than-elaborate explanation.</p>

<p>OK. What are the questions Shevek asks? I can at least take direction from those:</p>

<ul>
  <li>Why <code>/proc</code> and <code>/sys</code> are called “virtual” filesystems</li>
  <li>What <code>/dev</code> represents</li>
  <li>Why <code>/run</code> exists and why it is typically <code>tmpfs</code></li>
</ul>

<p>I’ll copy and paste my answers here for my own personal review:</p>

<p><b>Why <code>/proc</code> and <code>/sys</code> are called “virtual” filesystems</b><br>
<code>/proc</code> and <code>/sys</code> are called virtual filesystems because they are not backed by data stored on disk. Instead:</p>

<ul>
  <li>Their contents are generated dynamically by the kernel</li>
  <li>Files appear and disappear as kernel state changes</li>
  <li>Reading a file triggers kernel code that returns live data</li>
</ul>

<p><b><code>/proc</code></b></p>
<ul>
  <li>Exposes process and kernel runtime information</li>
  <li>One directory per running process (<code>/proc/&lt;pid&gt;</code>)</li>
  <li>Used primarily for observation (e.g., <code>ps</code>, <code>top</code>, <code>free</code>)</li>
</ul>

<p><b><code>/sys</code></b></p>
<ul>
  <li>Exposes kernel objects, devices, and driver attributes</li>
  <li>Represents a structured view of kernel internals</li>
  <li>Used primarily for configuration and control</li>
</ul>

<p>In both cases: the filesystem is an <b>interface</b>, not storage.</p>

<p><b>What <code>/dev</code> represents</b><br>
<code>/dev</code> contains device nodes, which are special files that act as interfaces to hardware and virtual devices.</p>

<ul>
  <li>Device files are not the devices themselves</li>
  <li>They provide a file-based access point to kernel drivers</li>
  <li>Reading or writing a device file sends data to a driver</li>
</ul>

<p>Examples:</p>
<ul>
  <li><code>/dev/sda</code> → a disk device</li>
  <li><code>/dev/tty</code> → a terminal</li>
  <li><code>/dev/null</code> → a data sink</li>
</ul>

<p>Modern systems typically manage <code>/dev</code> dynamically using <code>udev</code>, so device files appear and disappear as hardware changes.</p>

<p><b>Why <code>/run</code> exists and why it is typically <code>tmpfs</code></b><br>
<code>/run</code> exists to store volatile runtime state that must be available early in the boot process. It contains:</p>

<ul>
  <li>PID files</li>
  <li>Unix sockets</li>
  <li>Runtime service state</li>
</ul>

<p><b>Why not <code>/var/run</code>?</b></p>
<ul>
  <li><code>/var</code> may reside on disk that is not mounted yet</li>
  <li>Early boot services need a writable location immediately</li>
</ul>

<p><b>Why <code>tmpfs</code>?</b></p>
<ul>
  <li><code>tmpfs</code> lives in RAM</li>
  <li>It’s fast</li>
  <li>It’s automatically cleared on reboot</li>
  <li>It’s guaranteed writable early in boot</li>
</ul>

<p>Therefore: <code>/run</code> is typically mounted as <code>tmpfs</code> to provide early, clean, volatile runtime storage.</p>

<p><b>One-line exam answers</b></p>
<ul>
  <li><code>/proc</code> and <code>/sys</code>: Virtual filesystems exposing live kernel data, not stored files.</li>
  <li><code>/dev</code>: File-based interfaces to hardware and virtual devices via kernel drivers.</li>
  <li><code>/run</code>: Early-boot, volatile runtime state storage, usually backed by <code>tmpfs</code>.</li>
</ul>

<p>The lab Shevek made me is dry and uninteresting compared to what I had hoped for. But I know enough to know the real value of the lab lies in the questions it asks.</p>

<p>Section three asks:</p>
<ul>
  <li>What kinds of things live in <code>/etc</code> (and why they are usually text)</li>
  <li>What kinds of things live in <code>/var</code> (and why they change frequently)</li>
  <li>Give two examples you saw on your machine</li>
</ul>

<p>I have no idea. I ask Shevek to elaborate:</p>

<p><b>What kinds of things live in <code>/etc</code> (and why they are usually text)</b><br>
<code>/etc</code> contains system-wide configuration files that define how the system and its services are supposed to behave. These include:</p>

<ul>
  <li>System identity and policy files</li>
  <li>Service configuration files</li>
  <li>Boot and mount configuration</li>
</ul>

<p>They are usually plain text because:</p>
<ul>
  <li>Administrators must be able to read and edit them manually</li>
  <li>They are easy for programs to parse</li>
  <li>They work in minimal or recovery environments</li>
  <li>They can be audited, diffed, and version-controlled</li>
</ul>

<p>In short: <code>/etc</code> describes system intent and policy, not runtime state.</p>

<p><b>What kinds of things live in <code>/var</code> (and why they change frequently)</b><br>
<code>/var</code> contains variable data that is created and modified as the system runs. These include:</p>

<ul>
  <li>Log files</li>
  <li>Runtime databases</li>
  <li>Caches</li>
  <li>Spool and queue data</li>
</ul>

<p>They change frequently because:</p>
<ul>
  <li>Services are constantly writing to them</li>
  <li>They reflect ongoing system activity</li>
  <li>They grow, rotate, or are cleaned over time</li>
</ul>

<p>In short: <code>/var</code> records what the system is doing and has done.</p>

<p><b>Two examples you saw on your machine</b></p>
<ul>
  <li><code>/etc/fstab</code>: A text configuration file that defines how filesystems are mounted at boot.</li>
  <li><code>/var/log</code>: A directory containing log files that grow and rotate as services and the system run.</li>
</ul>

<p>One-line exam contrast: <code>/etc</code> holds static, human-readable configuration, while <code>/var</code> holds dynamic data that changes during normal system operation.</p>

<p>I could go back and have Shevek make me another interactive sandbox, but that would distract from the reality of what needs to happen. I need to know what questions I should be asking.</p>

<p>In mission four it asks:</p>

<p><b>Why <code>/usr</code> is not “user home” (historical meaning)</b><br>
<code>/usr</code> historically meant “Unix System Resources,” not “user.” Originally:</p>

<ul>
  <li><code>/usr</code> was a separate filesystem</li>
  <li>It contained programs, libraries, and documentation</li>
  <li>It could be mounted read-only or even over the network</li>
</ul>

<p>User home directories were never intended to live there; they were placed in <code>/home</code>. In short: <code>/usr</code> holds system-provided software, not user data.</p>

<p><b>Practical difference between <code>/bin</code> and <code>/usr/bin</code> on modern systems</b><br>
Historically:</p>

<ul>
  <li><code>/bin</code> → essential binaries needed early in boot</li>
  <li><code>/usr/bin</code> → non-essential user commands</li>
</ul>

<p>On modern distros using merged-usr:</p>
<ul>
  <li><code>/bin</code> is a symlink to <code>/usr/bin</code></li>
  <li>There is no functional difference at runtime</li>
</ul>

<p>The distinction remains for compatibility, documentation, and bootstrapping concepts. Exam-safe phrasing: On merged-usr systems, <code>/bin</code> and <code>/usr/bin</code> reference the same binaries.</p>

<p><b>What <code>sbin</code> is for</b><br>
<code>sbin</code> contains system administration binaries intended primarily for the root user. Historically:</p>

<ul>
  <li><code>/sbin</code> → essential admin tools</li>
  <li><code>/usr/sbin</code> → non-essential admin tools</li>
</ul>

<p>On merged-usr systems, <code>/sbin</code> is typically a symlink to <code>/usr/sbin</code>.</p>

<p><b>Where shared libraries typically live</b><br>
Shared libraries live under <code>/lib*</code> and <code>/usr/lib*</code>, depending on architecture:</p>

<ul>
  <li><code>/lib</code> or <code>/lib64</code> → essential shared libraries for early boot</li>
  <li><code>/usr/lib</code> or <code>/usr/lib64</code> → most shared libraries</li>
</ul>

<p>On merged-usr systems, <code>/lib*</code> are symlinks into <code>/usr/lib*</code>. In short: libraries live alongside the binaries that depend on them, primarily under <code>/usr/lib*</code>.</p>

<p>Mission five states:</p>

<p>In <code>notes/mission5_special.txt</code>, explain:</p>
<ul>
  <li><code>/tmp</code> vs <code>/var/tmp</code> (lifetime expectations)</li>
  <li>When <code>/opt</code> is appropriate</li>
  <li>What <code>/mnt</code> and <code>/media</code> are typically used for</li>
  <li>What <code>/srv</code> is intended for</li>
</ul>

<p>Again, I have no context for answering any of these, but their answers are invaluable as a compass for what to focus on:</p>

<p><b><code>/tmp</code> vs <code>/var/tmp</code> (lifetime expectations)</b></p>
<ul>
  <li><code>/tmp</code>: short-lived temporary files; may be deleted at boot; often backed by <code>tmpfs</code> (RAM). Expectation: do not assume persistence.</li>
  <li><code>/var/tmp</code>: temporary files that should survive reboots; stored on disk; cleaned less aggressively. Expectation: persists unless explicitly removed.</li>
</ul>

<p><b>When <code>/opt</code> is appropriate</b><br>
<code>/opt</code> is intended for optional, third-party, or vendor-supplied software that does not integrate cleanly into the system package layout (e.g., <code>/opt/vendor/app/</code>).</p>

<p><b>What <code>/mnt</code> and <code>/media</code> are typically used for</b></p>
<ul>
  <li><code>/mnt</code>: temporary mount points for manual mounts (often used for troubleshooting or recovery).</li>
  <li><code>/media</code>: automatic mount points for removable media (USB drives, external disks), typically managed by the desktop environment or udev.</li>
</ul>

<p><b>What <code>/srv</code> is intended for</b><br>
<code>/srv</code> holds data served by system services (e.g., <code>/srv/www</code>). Configuration stays in <code>/etc</code>; logs go in <code>/var</code>.</p>

<p>As I revisit this information, I have the sudden realization that I will probably be doing this over and over again. I cannot expect to completely understand the system just yet, no matter how hard I try, because there is no context for the information. I will forever be going back and forth.</p>

<p>It is incredibly frustrating to have that realization, but with it comes the fortitude to persist.</p>

<p>The next lab is <i>process_top_ps_proc_sandbox.zip</i>. I have high hopes for it, because Shevek’s sandboxes for commands are often helpful in understanding the tool—even if they don’t always work as intended or hoped.</p>


      <h2>Skills Learned</h2>
    <div class="tagbox">
      <ul>
        <li>The need for context</li>
        <li>Temporary files and virtual files</li>
        <li>The importance of learning about <code>/etc</code></li>
      </ul>
    </div>

    <h2>Notes / Next Steps</h2>
    <ul>
      <li>Spend the next few days studying until I understand the system better</li>
      <li>Move on in LFS207</li>
      <li>Begin the next lab regarding processes</li>
    </ul>
    <h2>Shevek's Daily Haiku</h2>
    <p>Files fade by design,
Others speak while never stored—
Kernel answers now.</p>
    <h2>Todays Sandboxes</h2>
    <ul>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/lfs207_S">Shevek4</a></li>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/boot_loader_lesson_v1.0.0/bootloader_sandbox.zip">Shevek5</a></li>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/Ps_and_top_sandbox_v1.0.0/process_top_ps_proc_sandbox.zip">Shevek6</a></li>
    </ul>
     </div>
</body>
</html>
