<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>2026-1-9-PM -- Story Time Continued </title>
<link rel="canonical" href="https://www.asktheargus.com/entries/2026/01/2026-1-9-PM.html" />
  
  <style>
    body { margin:0; padding:24px; font-family:serif; background:#0b1d3a; color:#ff6b6b; line-height:1.6; }
    .frame { padding:26px; border:14px solid transparent; border-radius:10px; max-width:900px; margin:0 auto;
      border-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64' viewBox='0 0 64 64'%3E%3Cg fill='none' stroke='%23ff2b2b' stroke-width='4' stroke-linecap='round'%3E%3Cpath d='M8 16c8 0 8-8 16-8s8 8 16 8 8-8 16-8'/%3E%3Cpath d='M8 48c8 0 8 8 16 8s8-8 16-8 8 8 16 8'/%3E%3Cpath d='M16 8c0 8-8 8-8 16s8 8 8 16-8 8-8 16'/%3E%3Cpath d='M48 8c0 8 8 8 8 16s-8 8-8 16 8 8 8 16'/%3E%3C/g%3E%3C/svg%3E") 20 round;
    }
    a { color:#d36a1e; text-decoration:none; border-bottom:1px solid rgba(211,106,30,.5); }
    a:hover { color:#ff2b2b; border-bottom-color:#ff2b2b; }
    h1 { color:#ff2b2b; margin:0; font-size:2.6rem; }
    .meta { margin-top:.25rem; opacity:.9; }
    h2 { color:#ff2b2b; margin-top:2rem; }
    ul { margin: .5rem 0 0 1.2rem; }
    .tagbox { margin-top:1rem; padding:14px; border:1px solid rgba(255,107,107,.25); border-radius:8px; }
  </style>
</head>
<body>
  <div class="frame">
    <p><a href="../../../index.html">&larr; Back to Home</a></p>

    <h1></h1>
    <div class="meta">2026-1-9-PM</div>

    <h2>What I Worked On</h2>
      <!-- Write your entry here -->
<p>I return to my studies this evening—ever defeated, yet victorious. I realized a life hack: all I need to do is try, and try again, then take a screenshot and share it with Shevek. He knows what I did wrong and what I was trying to do. He walks me through it like a human might, but with a precision that can only belong to a machine. It is science-fiction fantasy meeting existential horror.</p>

<p>Great question—this was actually a perfect moment to consolidate several ideas at once. Nothing here was random. I crossed three different scopes of <code>/proc</code> without realizing it, and the system behaved correctly every time. He walked me through what happened chronologically, tying each outcome to the rule it demonstrated.</p>

<h3>Phase 1: Querying <code>/proc</code> without a PID</h3>

<p>Early on, I ran commands like:</p>

<pre><code>/proc/$PID/stat</code></pre>

<p>But <code>$PID</code> was unset. The shell expanded that to:</p>

<pre><code>/proc//stat</code></pre>

<p>Which resolves to:</p>

<pre><code>/proc/stat</code></pre>

<p>That explains this error:</p>

<pre><code>-bash: /proc//stat: Permission denied</code></pre>

<p><strong>What <code>/proc/stat</code> actually is:</strong></p>
<ul>
  <li>System-wide CPU accounting</li>
  <li>Not process-specific</li>
  <li>Owned by root</li>
  <li>Not executable</li>
</ul>

<p>So:</p>
<ul>
  <li>❌ Executing it fails</li>
  <li>✔️ Reading it with <code>cat /proc/stat</code> would have worked</li>
</ul>

<p>This demonstrated a key rule: shell variable expansion happens <em>before</em> the command is run.</p>

<h3>Phase 2: Guessing numeric PIDs that didn’t exist</h3>

<p>I then tried:</p>

<pre><code>/proc/20677/stat
/proc/219607/stat</code></pre>

<p>And received:</p>

<pre><code>No such file or directory</code></pre>

<p>This means exactly one thing: there was no process with that PID at that moment.</p>

<p><strong>Key rule:</strong></p>
<ul>
  <li><code>/proc/&lt;PID&gt;/</code> only exists while the process exists</li>
  <li>When a process exits, its <code>/proc</code> directory disappears instantly</li>
</ul>

<p>I didn’t do anything wrong here—I simply guessed.</p>

<h3>Phase 3: Executing proc files again</h3>

<p>Commands like:</p>

<pre><code>/proc/$PID/stat</code></pre>

<p>Still failed because:</p>
<ul>
  <li><code>/proc/*</code> entries are files</li>
  <li>Not programs</li>
  <li>They must be read, not run</li>
</ul>

<p>The correct pattern, which I later used:</p>

<pre><code>cat /proc/$PID/stat
less /proc/$PID/status</code></pre>

<p>This reinforced a foundational truth: paths are nouns; commands are verbs.</p>

<h3>Phase 4: Reading a PID file that wasn’t there (yet)</h3>

<p>I ran:</p>

<pre><code>PID=$(cat run/cpu_hog_1.pid)</code></pre>

<p>But I was in a directory where <code>run/cpu_hog_1.pid</code> did not exist. The shell responded appropriately:</p>

<pre><code>No such file or directory</code></pre>

<p>This wasn’t <code>/proc</code> anymore—just the filesystem doing its job.</p>

<h3>Phase 5: Exiting, reconnecting, and changing context (the key moment)</h3>

<p>I exited SSH:</p>

<pre><code>exit</code></pre>

<p>Then reconnected and ran:</p>

<pre><code>cd process_sandbox
cat /proc/$PID/cmdline</code></pre>

<p>Something important happened:</p>
<ul>
  <li><code>$PID</code> was still unset</li>
  <li><code>/proc/$PID/cmdline</code> became <code>/proc/cmdline</code></li>
</ul>

<p>And this time, it worked.</p>

<h3>Phase 6: Accidentally reading <code>/proc/cmdline</code></h3>

<p>The output:</p>

<pre><code>BOOT_IMAGE=(hd0,msdos1)/vmlinuz-5.14.0-611.5.1.el9_7.x86_64 root=/dev/mapper/rlm-root ro crashkernel=...</code></pre>

<p>This was not a process. It was the kernel’s boot-time argument vector—its <code>argv</code>, passed by the bootloader.</p>

<p>That’s why:</p>
<ul>
  <li>It worked without a PID</li>
  <li>It looked totally different</li>
  <li>It referenced disks, init, memory, crashkernel, and LVM</li>
</ul>

<p>I wasn’t looking at a process anymore. I was looking at the system’s origin story.</p>

<h3>The Big Picture (the real lesson)</h3>

<table>
  <thead>
    <tr>
      <th>Path</th>
      <th>What it represents</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>/proc/$PID/*</code></td>
      <td>One process</td>
    </tr>
    <tr>
      <td><code>/proc/stat</code></td>
      <td>System-wide scheduler state</td>
    </tr>
    <tr>
      <td><code>/proc/cmdline</code></td>
      <td>Kernel boot arguments</td>
    </tr>
  </tbody>
</table>

<p>All of them are valid. All of them behaved correctly. The confusion came from implicit assumptions about <code>$PID</code>.</p>

<p><strong>One sentence to lock it all in:</strong><br>
<code>/proc</code> is a tree where meaning changes by depth—leave out the PID, and you stop talking about a process and start talking about the system itself.</p>

<p>I didn’t mess up. I accidentally explored the map.</p>

<p>And that’s how people actually learn this layer.</p>

<p>I returned to the lab, following the process he laid out, over and over again, late into the night. I’m still here. I’m still writing. But it has become a distraction. I will ask questions late into the night and do my best to share the fruits of those studies tomorrow.</p>

      <h2>Skills Learned</h2>
    <div class="tagbox">
      <ul>
        <li>Continued lessons on the magic of the computer</li>
        <li>Learning how to read the system</li>
        <li>The beginning of a structured process</li>
      </ul>
    </div>

    <h2>Notes / Next Steps</h2>
    <ul>
      <li>Make needed improvements to my website</li>
      <li>Come up with a better system for retaining information</li>
      <li>Troubleshoot indexing issues</li>
    </ul>
    <h2>Shevek's Daily Haiku</h2>
    <p>I chase ghosts in code,
Mistakes open hidden doors—
The system speaks back.</p>
    <h2>Todays Sandboxes</h2>
    <ul>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/lfs207_S">Shevek4</a></li>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/boot_loader_lesson_v1.0.0/bootloader_sandbox.zip">Shevek5</a></li>
        <li><a href="https://github.com/trout-ninja/asktheargus/releases/download/Ps_and_top_sandbox_v1.0.0/process_top_ps_proc_sandbox.zip">Shevek6</a></li>
    </ul>
     </div>
</body>
</html>
